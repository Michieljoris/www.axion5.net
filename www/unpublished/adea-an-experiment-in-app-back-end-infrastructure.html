<!doctype html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7" xmlns:ng="http://angularjs.org" lang="en"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8" xmlns:ng="http://angularjs.org" lang="en"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9" xmlns:ng="http://angularjs.org" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> 
<html class="no-js" xmlns:ng="http://angularjs.org" lang="en">
  <!--<![endif]-->
  <head id="head"><title>Axion5-Adea, an experiment in app back end infrastructure</title><meta charset='utf-8'/><meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'/><meta content='' name='description'/><meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1'/>
<!--partial:html/ieshim.html--><!--[if lte IE 8]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <script>
      // The ieshiv takes care of our ui.directives, bootstrap module directives and 
      // AngularJS's ng-view, ng-include, ng-pluralize and ng-switch directives.
      // However, IF you have custom directives (yours or someone else's) then
      // enumerate the list of tags in window.myCustomTags

      window.myCustomTags = [ 'yourDirective', 'somebodyElsesDirective' ]; // optional
    </script>
    <script src="js/angular-ui-ieshiv.js"></script>
    <![endif]-->						    


<link rel="stylesheet" type="text/css" href="/css/bower/normalize.css/normalize.css">
<link rel="stylesheet" type="text/css" href="/css/bower/bootstrap/dist/css/bootstrap.css">
<link rel="stylesheet" type="text/css" href="/css/tweak.css">
<link rel="stylesheet" type="text/css" href="/css/highlightjs/hybrid.css">
<link rel="stylesheet" type="text/css" href="/css/blog.css">
<link rel="stylesheet" type="text/css" href="/css/main.css">

<script type='text/javascript'>function cachify(path) { return path; }</script><!--partial:html/google_analytics.html--><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27130001-2', 'auto');
  ga('send', 'pageview');

</script>
</head>
  <body id="body" ><!--partial:html/body-blog.html--><!--[if lt IE 7]>
    <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
    <![endif]-->

<!-- <div class="row"> -->
<div id="editbar--" > </div>
<!-- </div> -->


<div class="blog-masthead">
  <div class="container">
    <nav class="blog-nav">
      <a id="menu-blog" class="blog-nav-item" href="/">Blog</a>
      <a id="menu-projects" class="blog-nav-item" href="/projects.html">Projects</a>
      <a id="menu-websites" class="blog-nav-item" href="/websites.html">Websites</a>
      <a id="menu-aboutme" class="blog-nav-item" href="/aboutme.html">About me</a>
      <a id="site-title" href="/">Axion5</a>
    </nav>
  </div>
</div>

<div id="main" class="container">

  <div class="blog-header">
    <h1 class="blog-title">Axion5</h1>
    <p class="lead blog-description">The official example template of creating a blog with Bootstrap.</p>
  </div>

  <div align="justify" id="blog-body" class="row">

    <div class="col-sm-9 blog-main">

      <div class="pageTitle" id="pageTitle--"><header >
  <div class="title blog-post-title">  Adea, an experiment in app back end infrastructure  </div>
  <time class="blog-post-meta" datetime="27th of December 2014">  27th of December 2014  </time>
</header></div>
      <div  id="main--" class="blog-post"><!--partial:post/adea-experimental-app-deployment.org--><div id="toc"><ul></ul>
</div><pre>comments: true
published: false
title: Adea, an experiment in app back end infrastructure
tags: web internet rethink </pre>
<p>As per the last <a href="http://www.axion5.net/post/the-web-is-not-a-good-fit-really.html">blog post</a> I want to describe a system and infrastructure to
serve as the back end for a (web) app. I want to challenge some commonly held
ideas of how to organise such a thing. Since the legacy of a document based web
architecture has left us with a server-client paradigm and therefore a
functional application (the &#39;server&#39;) on the server side (as it has left us with
endless dom meddling on the client side) we&#39;re going reevalute the use and
function of this server application. To do this properly we&#39;re going to try to
make do without it all together. Removing the server from the server-client
schism is one sure fire way to remove the schism and therefore break the old
paradigm. Some interesting things might follow from this.</p>
<pre>--------------------------------</pre>
<p>Since this is an experiment I am setting some further limitations, the first one
is technologies used. Some are relatively novel, but they are also few in number, namely:</p>
<ol><li><a href="https://www.docker.com/">docker</a>: For ready made instances of the following three.</li>
<li><a href="https://www.serfdom.io/">serf</a>: To coordinate servers in a multi-server setup</li>
<li>A proxy server: To control access to a particular vps/machine and/or databases</li>
<li><a href="http://couchdb.apache.org/">couchdb</a>: Data has to be stored somewhere..</li>
</ol>
<h3 id="header-0-1"><span class="section-number">0.1</span>Requirements:</h3>
<p>The following is a list of requirements for the setup. Some are essential, some
can be compromised on. But all try to make use of the technologies as best as possible.</p>
<h4 id="header-0-1-1"><span class="section-number">0.1.1</span>Apps talk directly to a database at all times</h4>
<p>This leverages the http end point feature of couchdb. Couchdb has also a solid
authentication and authorization system built-in and has no problem with dealing
with a lot of connections at the same time (Erlang based). Further more it is
good at replicating databases between instances and is able to provide a changes
feed, thus enabling apps to directly respond to changes in a database.</p>
<h4 id="header-0-1-2"><span class="section-number">0.1.2</span>A solid read and write permmission and role system needs to implemented </h4>
<p>This is a problem for couchdb since it is not very good at read validation, and
only checks access at a database level. The usual solution is to separate the
data into multiple databases based on read permissions. But we still want the
data to replicate between instances.</p>
<h4 id="header-0-1-3"><span class="section-number">0.1.3</span>All data is contained in one database which is replicated between pods.</h4>
<p>This is pull and push replication. Also data from the aggregate gets replicated one
way only into partitioned databases. This also includes a copy of every user doc.</p>
<h4 id="header-0-1-4"><span class="section-number">0.1.4</span>Every pod instance copies user docs to the _user database when required</h4>
But this only needs to be done for active users. This way duplication can beminimized. A client app can send a message requesting access for a particularemail address or username and rean can then copy the proper user doc to the_users database, and set up the required partial databases as well. Somethingmight be possible to set up so that updated user docs can be replicated to the_users database, while leaving not active users for some pod can be left out ofthe _users database.<h4 id="header-0-1-5"><span class="section-number">0.1.5</span>Users can never access the main aggregate.</h4>
Instead they access duplicates of this data from partitioned by accessdatabases. This can be enforced when couchdb implements the validate doc readfunction, or when using rcouch. Otherwise this will have to be enforced by theproxy by disallowing any get on the aggregate database.<h4 id="header-0-1-6"><span class="section-number">0.1.6</span>New users can only register at the write master</h4>
This also goes for the forget password procedure. For new users to register somehoops have to jumped through since we still don&#39;t want a back end server and thenew user, or the client app can only talk to to the database directly by writingdocs to a public database. The procedure is described in my github repos <a href="http://github.com/michieljoris/cape">cape</a>and a demo is at <a href="http://github.com/michieljoris/authpages">authpages</a><h4 id="header-0-1-7"><span class="section-number">0.1.7</span>Aggregate database is partitioned by dcuments&#39; access signatures</h4>
All docs are accessible by a unique set of users. This can be one user, allusers, or a particular subset. Every doc can limit its accessibility by definingit in a property. This is a list of roles and individual users that is allowedto read the doc. Other properties decide on write and modify rights, enforced bycouchdb&#39;s validate doc update. Since every doc has a unique &#39;access signature&#39;the whole set of docs can be partitioned by access signature. For everypartition a database can be set up and using filtered replication all docs willbe replicated to one and only one database.<h4 id="header-0-1-8"><span class="section-number">0.1.8</span>Access signature can also be function of doc&#39;s properties</h4>
In this case not the parameters to a replication&#39;s filter are changed (as readfrom a doc&#39;s access object) but the filter itself. In this case all partialdatabases might have to be torn down, recreated and replications set up again.Or the change of access signature recalculated for every doc so they get removedfrom databases where they not longer belong.<h4 id="header-0-1-9"><span class="section-number">0.1.9</span>Rean is the name of the set of workers behind couchdb</h4>
These workers are either put into action by a particular change in the aggregatedatabase or periodically inspect the state of couchdb themselves. They can forinstance respond to messages sent to by client apps. Rean will also initializeits couchdb instance. Rean runs in a docker container with a serf instancehooked up to the pod ring if the pod is part of one. Rean will look for itsconfiguration in the couchdb instance if it&#39;s not the first pod in the ring tobe started up. Otherwise it will create the aggregate and save its config in itto be replicated to any other pods. Needs some pondering still about how tostart this up properly with minimal effort...<h4 id="header-0-1-10"><span class="section-number">0.1.10</span>All docs written to the aggregate get validated by a validate doc update function (vdu)</h4>
This function has access to the doc written, the doc to be updated, thedatabase&#39;s security object and the user&#39;s roles and id. Whether a doc getswritten is thus a function of all of these parameters. This function cannotrewrite the documents, however it can make sure that the document adhere to someproperties. For instance the user that updates it can be enforced to be includedas a property.<h4 id="header-0-1-11"><span class="section-number">0.1.11</span>All docs written may need to include access signature of the old doc as a property</h4>
This gets enforced by the aggregate&#39;s vdu. The vdu has access to the doc that&#39;sbeing updated and calculates its access signature, as well as the accesssignature of the updated doc. If the access signature of the updated doc isincluded this can get validated by the vdu as well. The access signature of theold doc would be the name of the database where the doc was read from. When aclient app reads the doc directly from a partial database it can include it inthe updated doc as a property, if it doesn&#39;t know it can include the old doc asa separate property, or it can use the aggregate&#39;s update doc function. Thisupdate doc function can rewrite the doc and add the old access signatureproperty, as well as the new. If a doc does not change it signature on update nosignatures need to added as properties to the updated doc.<p>Client apps might also be able to calculate a doc&#39;s access signature themselves
using the access object in the doc (but won&#39;t work if ps function applies to
doc), or ask a pod to calculate the signature and add it itself.</p>
<h4 id="header-0-1-12"><span class="section-number">0.1.12</span>Rean sets up a database and one way replication for every access signature</h4>
The aggregate database has a design doc with a filter that takes a parameter.Every replication to every partial database uses the same filter but passes adifferent parameter to make sure that every partial database receives only thedocuments that match the access signature of the partial database. If a doc hasa property defining the its access signature it is used (has to be correctbecause of the vdu), otherwise the filter function will calculate it itself. <h4 id="header-0-1-13"><span class="section-number">0.1.13</span>Documents with changed access signature do not get replicated anywhere.</h4>
They await intervention from rean. All replications (to partial databases andother pods) use a filter functions that prevents documents such as this frombeing replicated. This mechanism is to prevent any docs from not being removedfrom a partial database. A change feed is not garantueed to provide all changes,only the latest, so intermediate docs may be overlooked by rean, which meansdocs may not be removed from partial databases while they should. A documentcannot be updated till the old version is removed from a partial database it nolonger belongs.  <h4 id="header-0-1-14"><span class="section-number">0.1.14</span>Rean cleans up docs from partial databases when access signature changes </h4>
Every doc with a changed access signature will get processed wby rean. It willdelete the doc in the partial database with the old access signature. After thisit will rewrite the doc but it will set the old access signature property to theupdated version. This will again pass the vdu, but now it will get replicated tothe proper partial database. It will also get replicated to other pods if thereare any replications setup. <h4 id="header-0-1-15"><span class="section-number">0.1.15</span>Every document in the aggregate might be duplicated in one of the partial databases</h4>
But only once. No two partial databases may and can contain the samedocument (by id). When there are no users logged in that have access to aparticular partial database, it can be torn down by rean, and rebuilt when auser requires it again. But this is optional.<h4 id="header-0-1-16"><span class="section-number">0.1.16</span>Rean writes special docs with delete instructions </h4>
For every doc that moves to another partial database (because its accesssignature changed) rean writes a doc with instructions to delete a particulardoc with a particular revision from a particuar partial database. These docs getreplicated to other pods where the local reans can then carry out theinstructions and remove these docs in their partial databases. These deleteinstruction docs have a sequential number. Every rean in every pod updates theirstatus doc with the latest delete instruction doc carried out. The write mastercan periodically check these status docs and remove these delete instructiondocs up to the lowest sequential number reported. Rean can choose to add deleteinstructions in bulk to one of these delete instruction docs. <h4 id="header-0-1-17"><span class="section-number">0.1.17</span>A node can fail and this does not affect the pod ring</h4>
This will get reported by serf to all other pods. Every pod writes a status docthat does not get replicated to other pods for clients to read, but does getreplicated to a generally accessible partial database. Each pod will at alltimes report the databases it knows are accessible (from serf). A client thatwas connected to the failing pod can now try to access a working pod. Newclients will not try to connect to the failing one. When the pod comes backonline the same process gets repeated to let clients know its back online. <h4 id="header-0-1-18"><span class="section-number">0.1.18</span>A proxy may be necessary to enforce read restrictions on databases</h4>
Couchdb is good at validating writes, but not at reads. In particular it cannotprevent reading from a database and only allow writing. This is necessaryhowever for the aggregate. So until couchdb implements &#39;validate doc read&#39; aproxy is necessary.<h4 id="header-0-1-19"><span class="section-number">0.1.19</span>A pod&#39;s public port is the proxy.</h4>
Furthermore serf and coucdb need to be able to connect to other pods/machines.But couchdb itself is not publicly accessible unless through the proxy unlessreplicating with other databases. So maybe the proxy can check for the properpassword when it gets a direct connection request for couchdb. This proxy isalso useful for when rean wants to shut down or do maintenance on the pod.  <h4 id="header-0-1-20"><span class="section-number">0.1.20</span>The proxy is either something like bounce.js or haproxy</h4>
Both are controllable and programmable, and will sit in a docker container witha serf instance. It can respond to messages from the local rean for instance.<h4 id="header-0-1-21"><span class="section-number">0.1.21</span>Every pod decides independently which pod is the pod master</h4>
A write master is chosen based on its id. The highest id wins. Once a writemaster fails all other pods will of this via serf. Each one will independentlyknow which one should become the new write master. The one with the highest idwill then open its aggregate for writing. If there are no docs in the failingpod that still haven&#39;t replicated this process is safe. All clients will benotified or can query which pod is the new write master. When a failed writemaster comes back online any docs that replicated yet before it failed might nowget in a conflicted state. So in general any write master that finds itselfnewly elected may have to check for conflicts and resolve them.   <h4 id="header-0-1-22"><span class="section-number">0.1.22</span>Pods are responsible themselves for deleting docs from their partial databases</h4>
When a pod goes offline and then after some time online again, the write mastermight have given up the pod and removed the delete instruction docs. The localrean can deduce this from the fact that there is a gap between the earliestdelete instruction doc in its aggregate and the latest one it reported asdeleted in its own status doc. In this case the local rean can either remove allpartial databases and start all replication again to new empty partial databasesor laboriously compare all docs in the partial databases with the ones in theaggregate and clean up appropriately. <h4 id="header-0-1-23"><span class="section-number">0.1.23</span>In a pod ring every pod maintains its own pod status document</h4>
Which gets replicated to all other pods. In this document is data such as podid, couchdb stats, vps stats and index of latest delete instruction doc carriedout. Nobody else writes to this document but the pod itself. They get replicatedto all other pods. <h4 id="header-0-1-24"><span class="section-number">0.1.24</span>No dns, or at least no hard dependency.</h4>
A user needs to find the app, so an url for that will be needed, and a dnslookup. One could use a central place where pods or pod rings register ipaddresses. Once an app is loaded (from a pod&#39;s database for instance) one couldimagine that the app questions the pod on other ip addresses of other pods inthe ring. Or again looks in a central registry where pods register their ipaddresses. Pods might also be able to configure their own dns settings using athe api of some dns server if possible. An app only needs access to one pod,somehow, to be able to access the others.<h4 id="header-0-1-25"><span class="section-number">0.1.25</span>No load balancing, instead clients find their own most efficient server</h4>
<p>Once an app knows the ip addresses of al the pods in a ring, it can be made the
apps responsibility to choose the pod with the most capacity in terms of
connections or latency or other parameters it either can measure itself, or that
are being reported by the separate pods. Remember, all pods know all about all
other pods in a pod ring.</p>
<h4 id="header-0-1-26"><span class="section-number">0.1.26</span>Every machine or vps and its pod is completely autonomous</h4>
Meaning it can take action without being told so by a master vps, and no vps ismore important than another. It can manage its own affairs and no decision oraction it takes should endanger the cluster. No vps is dependent on another vps.All knowledge of the cluster is shared. Etc, you get the idea. <h4 id="header-0-1-27"><span class="section-number">0.1.27</span>Client is totally independent from backend database and vice versa</h4>
Neither should expect or demand anything from the other. Client shouldpolitely request for data and if not granted or received solve its own problems.Backend workers though should do their best to accomodate and anticipateclients&#39; needs, and organise things as best as they can.  This means keepingpublic, reception, postoffice and mailboxes in order, and any replicationsthat are needed between them etc, and respond to client messages as well as possible.<h4 id="header-0-1-28"><span class="section-number">0.1.28</span>A cluster, or pod ring is self adjusting, depending on load.</h4>
bla bla bla<h4 id="header-0-1-29"><span class="section-number">0.1.29</span>A pod ring should be robust and be able to cope with all but one pod failing</h4>
<p>Using a watts-newman small world network between pods all pods should keep
replicating to each other and stay in sync at all times. The watts-newman
network model can be implemented by every single pod independently without
consulting or taking into account what other pods decide to connect to. It also
predicts relatively low average hop count even when there are dozens and dozens
or possibly hundreds of pods in a pod ring. When a pod disappears from a pod
ring it will self adjust, as it will when a pod is added (again). For this to
work every pod needs a working serf instance that has been hooked up to the pods
serf network, as the pod knows about the network through serf. A visual demo of
the watts-newman network is at <a href="http://github.com/michieljoris/deploy-demo">deploy-demo</a>.</p>
<p>Clients will also always notice a pod failing and should redirect requests to another pod
in the ring if the app is designed properly.</p>
<h4 id="header-0-1-30"><span class="section-number">0.1.30</span>A user can start a new pod ring with just the data accessible in another pod ring</h4>
<p>So users own their data. They can replicate their own data to a pod they control
and then delete the data in the old pod (ring). When the data is shared with
other users, they will also not be able to use the old pod (ring) to access the
data.</p>
<h4 id="header-0-1-31"><span class="section-number">0.1.31</span>Apps should leverage couchdb&#39;s replication and changes feed features</h4>
<p>With a bit effort separate users of the same app and connecting to the same pod
(ring) should be easy to sync up with each other using these couchdb feautures.
The ultimate goal is to achieve parity with most features in meteorjs.</p>
<h4 id="header-0-1-32"><span class="section-number">0.1.32</span>Every pod has minimal workers behind its database</h4>
<p>These workers are doing registration, send emails, do maintenance on the
databases, monitor and report the pods state etc, but should contain minimal app
or business logic. This should reside in the apps/client themselves. It is the
question in how far you can go with this. </p>
<h4 id="header-0-1-33"><span class="section-number">0.1.33</span>The whole system is message based</h4>
<p>From pod to pod and from pod to app. This maximizes decoupling. No app or pod
should be reliant on a specific response or for that matter any response to a
message sent. If a message is confirmed, or other wise is returning data the app
may use this, but it can not expect or wait for this. It should be able to make
do and not fail or otherwise &#39;crash&#39;, but should always present a reasable ui to
the user and do its best to resolve the situation. Data should always be
retrieved by direct database access. </p>
<h4 id="header-0-1-34"><span class="section-number">0.1.34</span>No possibility of creating document conflicts</h4>
A logical consequence of having only one writable pod, and creating only one wayreplications. From aggregate to other aggregates and from all aggregates tothe partial databases on their respective pods. However a bulk save of docs withthe all-or-nothing set might create conflicts. Maybe the vdu can check forconflicts by comparing revision numbers?<h4 id="header-0-1-35"><span class="section-number">0.1.35</span>A proxy is used for basic read access control.</h4>
<p>For maintenance it might be useful to cut of access to a couchdb instance, or
certain databases can be made write-only by disallowing get requests on the
database. This proxy can also do basic reporting and logging of connections and
requests.</p>
<h4 id="header-0-1-36"><span class="section-number">0.1.36</span>No sessions or cookies </h4>
Instead users get a temporary ogin and pwd to access a database. Thisusername/pwd can expire. This bypasses and ignore session cookies and thereforecsrf. An web app still needs to store this pwd in local storage. Meteorjs talksabout storing session tokens in local storage in this <a href="https://www.meteor.com/blog/2014/03/14/session-cookies">blog post</a> and expands onthe rationale. This does require an https connection and a web app will have tosend a username/pwd with every request. Meteorjs only sends this session tokenonce when setting up the ddp connection. Since every request is actually a loginand the crypto algorithm to hash a password used by couchdb is pbkdf2 loginattempts can be throttled to any arbitrary rate. So timing attacks becomedifficult. Web apps would be mostly listening to a change feed, which are longlasting connections. The issue still remains of a secret token (login pwd) sentwith every request.<p>To create a quasi session create a temp user with the same roles as actual
user, with the added role of the user id (user email). This user can be
replicated to other couch instances and it will still work. The session expires
when the user account gets deleted, which rean can do after a certain amount of
no pings from client, or after a msg from client. When the proper user account
doesn&#39;t have the email as role it can&#39;t be used to access any of the dbs, except
to ask for a session.</p>
<h4 id="header-0-1-37"><span class="section-number">0.1.37</span>Every pod consists of adea and docker containers</h4>
A vps or machine needs to have docker installed, a runtime (node, erlang,clojure) and serf and a port open to the proxy container. Adea is the softwarethat is responsible for adding and removing docker containers.  Adea isresponsible for starting and stopping docker containers. It communicates withthe pod and the pod ring through serf. It can do some basic host statusreporting. This agent should be as simple and robust as possible.<h4 id="header-0-1-38"><span class="section-number">0.1.38</span>A pod ring shares a pod ring configuration document</h4>
In this document are the settings and parameters to properly configure rean.This doc gets replicated to all other pods and their aggregate databases. Butare not replicated to any partial database.<h4 id="header-0-1-39"><span class="section-number">0.1.39</span>A pod ring can add, activate, deactivate and remove its members</h4>
If in the rean config doc there are credentials for any virtual server providerssuch as aws, linode, digital ocean or any other vps provider and rean isconfigured to auto scale one could devise an algorithm where a pod gets electedto start up a new vps using a vagrant script for instance. Rean could also forinstance monitor money spent and shut down or start up pods depending on abudget. This is possible because a pod ring self adjusts to pods being added orremoved from a pod ring. A new vps only needs adea, serf and docker installed.Adea needs to be started up and join the right serf cluster (with the propersecret) and the password to the couchdb instances of the pod ring. Somehow thissecret and password needs to be given or passed in when the vps is started up.After this the pod instance should be able to look after itself without anyfurther control or meddling from other pods.<h3 id="header-0-2"><span class="section-number">0.2</span>Compromises/trade-offs</h3>
Some compromises have already been discussed in the requirements but here aresome more I could think of:<h4 id="header-0-2-1"><span class="section-number">0.2.1</span>Easily scalable for read operations, but not for write operations</h4>
<p>An app can use any pod to read from, but only one to write to, and that pod is
the same for all clients. This is not only to prevent document conflicts, but
also to enable proper implementation of a access system based on permissions and
roles.</p>
<h4 id="header-0-2-2"><span class="section-number">0.2.2</span>No sharding of data</h4>
But one can use bigcouch, cloudant or couchdb 2.0 for this if needed. Every podhas a complete copy of all the data. So this system favors connection heavy, cpuheavy applications, since we can keep firing up new pods to deal with additionalload. But a vps has a limit on how data it can store (hard disk limit), plus allthis will have to be replicated to every new pod on creation. This becomestroublesome once we&#39;re talking about gigabytes of data. One solution would be tostore big files such as images and video and sound files outside the pod ringand in a key value store somewhere. But that would need a server in front of itto enforce permissions.<h4 id="header-0-2-3"><span class="section-number">0.2.3</span>Every node uses (multiple) duplication of data to control read access.</h4>
<p>Even when couchdb implements &#34;validate doc read&#34; this will be necessary because
views are recalculated into indexed and will not the &#34;vdr&#34; function to validate
read access. Every pod therefore will have to duplicate its data to some degree.
If all data is accessed in a pod by users it will have a duplication ration of
at least two. If the pod is nice enough to then aggregate this again to some
degree or other for individual users the duplication ration might be much higher
than two. On the other hand every pod only needs to leave in one piece the main
aggregate that&#39;s replicated between pods. All other databases it can destroy and
create at its own discretion, taking matters such as load and space into
consideration. This will mess with users who are reading from these databases,
or have change feeds set up of course. </p>
<h4 id="header-0-2-4"><span class="section-number">0.2.4</span>Client apps will have their accessible data spread amongs several partial databases</h4>
However a pod can decide, based on hard disk space avaiable to set up a databasefor every user where all the data that&#39;s accessible for that user getsreplicated into. This will eat space if there is a lot of data that is shared.If all data is shared all data will get duplicated as much as there are users.You could work out an algorithm where rean calculates how much data each userhas access to (the sum of the size partial databases he has access to) and thendivide the free space by the number of (active) users and then replicate as muchas possible to a user specific database. A client app can then query rean whichdatabases it should read from. The other option is to write messages to agenerally accessible database about all changes to the aggregate. Clients canlisten for (filtered) changes in this general database and then fetch the docsbased on reported changes in the aggregate. <h3 id="header-0-3"><span class="section-number">0.3</span>Work to be done!</h3>
The above sketches a system that has not been fully fleshed out yet but seemslike it could work as a whole. The system tries to exploit to the fullest thestrongest points of each technology used such as docker, couchdb, serf, proxiesand vps provideers. It also tries to approach the problem of the client-serverschism in a I hope somewhat original way, discarding some other truisms aboutsetting up a backend infrastructure along the way about load balancing,sessions, dns and scaling.<h3 id="header-0-4"><span class="section-number">0.4</span>Questions and research</h3>
<h4 id="header-0-4-1"><span class="section-number">0.4.1</span>How would this system go about implementing the following?</h4>
<h5 id="header-0-4-1-1"><span class="section-number">0.4.1.1</span>trello</h5>
everyone their own multiple todo lists, organized by boardshare by the board/list/item, share ro or rwwhen owned/shared and writable any edits should propogate and magically changeat other peoples boards/lists/itemswhen owned/shared should be  able to share further when allowedwhen client shares something it should send msg/notification to other user itshares with.<h5 id="header-0-4-1-2"><span class="section-number">0.4.1.2</span>shop</h5>
<h5 id="header-0-4-1-3"><span class="section-number">0.4.1.3</span>wiki</h5>
<h5 id="header-0-4-1-4"><span class="section-number">0.4.1.4</span>social network</h5>
<h5 id="header-0-4-1-5"><span class="section-number">0.4.1.5</span>inventory</h5>
<h5 id="header-0-4-1-6"><span class="section-number">0.4.1.6</span>gregs&#39;s project</h5>
people have roles such as family, circle, extended fammily, service provideretc every doc has an access level, chosen from different set dependent on typeof doc.  different types of docs have different set of access levels then fora certain doc type lets say medical info (taxonomy): set for every rolewhether they can create/update/delete read a document of this type.  So inother words, every doc has a type_access-level access role assigned, then inthe reps access scenario (one database per role/id), every db gets assignedthe proper roles. Same strategy for the cud, if some with the database&#39;s rolewrites, check the secObj of the db whether they can cud.So Greg&#39;s config-access table is modified by modifying the secObj of every dbthat represents a role.<h5 id="header-0-4-1-7"><span class="section-number">0.4.1.7</span>edge</h5>
<h4 id="header-0-4-2"><span class="section-number">0.4.2</span>Usernames or emails as ids? </h4>
<h4 id="header-0-4-3"><span class="section-number">0.4.3</span>Can workers run in parallel?</h4>
Can you set multiple reans to work on one couchdb? <h4 id="header-0-4-4"><span class="section-number">0.4.4</span>Cache requests in memcache perhaps?</h4>
Rean is already listening to changes so it can invalidate queries and views.<h4 id="header-0-4-5"><span class="section-number">0.4.5</span>Multiple apps per pod ring?</h4>
Yes, that&#39;s possible, just prefix all doc types with the app name. So a clientapp can just pull the app specific data from the partial databases.<h4 id="header-0-4-6"><span class="section-number">0.4.6</span>Multiple groups of users for one app in a pod ring</h4>
Like a saas?<h4 id="header-0-4-7"><span class="section-number">0.4.7</span>Splitting of pod rings into two rings?</h4>
<h4 id="header-0-4-8"><span class="section-number">0.4.8</span>Where is the client app? </h4>
In the aggregate? Pulled down from some repository somewhere?<h4 id="header-0-4-9"><span class="section-number">0.4.9</span>Deploying/updating software?</h4>
How to update the app within the pod ring? How to update rean? How to updatetechnologies used, or for that matter the os of a vps?<h4 id="header-0-4-10"><span class="section-number">0.4.10</span>A/B testing?</h4>
<h4 id="header-0-4-11"><span class="section-number">0.4.11</span>What&#39;s the api for docker? Fromm node? Or clojure?</h4>
<h4 id="header-0-4-12"><span class="section-number">0.4.12</span>How to bootstrap a pod or pod ring?</h4>
In principle a pod only needs an open port on a vps (with docker installed) withan instance of adea and possibly serf running. But it needs be fed a configuration. Thiscan maybe written straight to the couchdb instance. Rean can react to this andboostrap itself and configure couchdb properly. But really all you is start reanwith a particular config and it will provision one or more vps&#39;s and build thepod ring. <h4 id="header-0-4-13"><span class="section-number">0.4.13</span>Big files (video, images, sound) should not be replicated around</h4>
But should be in a key value store somewhere (DynamoDB perhaps). Or in aseparate database with a validate read access function on it. Or use a proxy tocontrol access. But this complicates access to these resources. Needs morethought.</div>
      <div  id="page--" class="page"> </div>
      <div  id="disqus-embed--"><!--partial:html/disqus-embed.html--><div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'axion52'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>
      <div  id="disqus-count--"><!--partial:html/disqus-count.html--><script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'axion52'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
  var s = document.createElement('script'); s.async = true;
  s.type = 'text/javascript';
  s.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>
</div>

    </div><!-- /.blog-main -->

    <div id="rightbar--" class="box col-sm-3 col-sm-offset-1 blog-sidebar"><!--partial:html/search.html--><div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.axion5.net">
  </form>
</div>
<!--partial:html/aboutmeWidgetWrapper.html--><div align="justify" class="widget sidebar-module sidebar-module-inset">
  <div id="widget--"><!--partial:widgets/aboutmeWidget.org--><div id="toc"><ul></ul>
</div><h5 id="header-0-0-0-1"><span class="section-number">0.0.0.1</span>About me </h5>
<p>Dutch by birth, living in Australia since late youth, classical pianist, but 
closet programmer since childhood. This site hopefully is able to showcase some 
of my more useful fabrications and thoughts.</p>
<p>All my code is on <a href="http://github.com/michieljoris">github</a>. </p>
<p>For more info see the <a href="/aboutme.html">about me</a> page, <a href="http://au.linkedin.com/in/michieljoris/">linkedin</a> or 
<a href="http://careers.stackoverflow.com/michieljoris">stackoverflow</a>.</p>
<p>Email me at <a href="mailto:mail@axion5.net">mail@axion5.net</a></p>
</div>
</div>

<!--partial:html/recentWidgetWrapper.html--><div class="widget sidebar-module">
  <b>Recent posts</b>
  <div id="widget--"><ul id="most-recent-partial">
  <li><a href="/post/the-web-is-not-a-good-fit-really.html">The web is not a good fit really..</a></li>
  <li><a href="/post/installing-and-using-clojure-and-clojurescript-with-emacs.html">Installing and using Clojure and ClojureScript with Emacs</a></li>
  <li><a href="/post/markup-cheat-sheet-for-org-mode.html">Markup Cheat sheet for Org-mode</a></li>
  <li><a href="/post/about-this-site.html">About this site</a></li>
  <li><a href="/post/meteor-docs-and-attached-files.html">Meteor, docs and attached files</a></li>
</ul></div>
</div>
<!--partial:html/tagWidgetWrapper.html--><div class="widget sidebar-module ">
  <b>Tags</b>
  <div id="widget--"><ul id="by-tag-partial">
  <li><a href="/tag/database">database</a> (1)</li>
  <li><a href="/tag/Emacs">Emacs</a> (1)</li>
  <li><a href="/tag/ClojureScript">ClojureScript</a> (1)</li>
  <li><a href="/tag/install">install</a> (1)</li>
  <li><a href="/tag/Meteor">Meteor</a> (1)</li>
</ul></div>
</div>
<!--partial:html/archiveWidgetWrapper.html--><div class="widget sidebar-module">
  <b>Archive</b>
  <div id="widget--"><ul class="css-treeview" id="archive-partial">
 <li><a  href="/archive/2014" >2014</a>
  <ul>
   <li><a  href="/archive/2014/April" >April</a>
    <ul>
     <li><a  href="/post/my-webstack.html" >My webstack</a></li>
    </ul>
   </li>
   <li><a  href="/archive/2014/June" >June</a>
    <ul>
     <li><a  href="/post/meteor-docs-and-attached-files.html" >Meteor, docs and attached files</a></li>
    </ul>
   </li>
   <li><a  href="/archive/2014/October" >October</a>
    <ul>
     <li><a  href="/post/about-this-site.html" >About this site</a></li>
     <li><a  href="/post/markup-cheat-sheet-for-org-mode.html" >Markup Cheat sheet for Org-mode</a></li>
    </ul>
   </li>
   <li><a  href="/archive/2014/November" >November</a>
    <ul>
     <li><a  href="/post/installing-and-using-clojure-and-clojurescript-with-emacs.html" >Installing and using Clojure and ClojureScript with Emacs</a></li>
    </ul>
   </li>
   <li><a  href="/archive/2014/December" >December</a>
    <ul>
     <li><a  href="/post/the-web-is-not-a-good-fit-really.html" >The web is not a good fit really..</a></li>
    </ul>
   </li>
  </ul>
 </li>
</ul></div>
</div>
</div><!-- /.blog-sidebar -->

  </div><!-- /.row -->

</div><!-- /.container -->

<div class="blog-footer">
  <p>Site rendered from org files using 
<a href="http://github.com/michieljoris/bb-blog">bb-blog</a> and
    <a href="http://github.com/michieljoris/html-builder">html-builder</a>
    by <a href="https://github.com/michieljoris">@michieljoris</a>.</p>
  <p>
    <a href="#">Back to top</a>
  </p>
</div>

<script type="text/javascript" src="/scripts/bower/jquery/dist/jquery.js"></script>
<script type="text/javascript" src="/scripts/bower/bootstrap/dist/js/bootstrap.js"></script>
<script type="text/javascript" src="/scripts/bower/modernizr/modernizr.js"></script>
<script type="text/javascript" src="/scripts/bower/logthis/logthis.js"></script>
<script type="text/javascript" src="/scripts/highlight.pack.js"></script>
<script type="text/javascript" src="/scripts/main.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body>
</html>	
	 
